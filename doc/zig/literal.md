# リテラル

- Zigのリテラルの書き方を確認する。
- リテラルはソースコード上で値を表したもの。

## `null`リテラル

- オプション型の値がないことを表す。

## 論理値リテラル

- `true`と`false`がある。
- 論理値リテラルの型は`bool`。

## 整数リテラル

- 10進数、2進数(`0b`)、8進数(`0o`)、16進数(`0x`)を使用できる。
- 見た目のために数字の間を`_`(アンダースコア)で区切ることができる。
- 桁の上限はない。
- 整数リテラルの型は`comptime_int`。

## 浮動小数点数リテラル

- 10進数、16進数(`0x`)を使用できる。
- 小数点(`.`)、指数(10進数は`e`と`E`、16進数は`p`と`P`)が使える。
- 見た目のために数字の間を`_`(アンダースコア)で区切ることができる。
- 桁の上限はない。
- `f128`と同じまでの精度が保証される。
- `NaN`と`infinity`を表すリテラルはない。
- 小数リテラルの型は`comptime_float`。

## Unicodeコードポイントリテラル

- `'`(シングルクォーテーション)で囲われた文字。
- 1つのUnicodeコードポイントを表す。
- Unicodeコードポイントリテラルの型は`comptime_int`。
- エスケープシーケンスが使える。
  - 改行(`\n`)
  - キャリッジリターン(`\r`)
  - タブ文字(`\t`)
  - バックスラッシュ(`\\`)
  - シングルクオーテーション(`\'`)
  - ダブルクオーテーション(`\"`)
  - 16進数のコードポイント指定文字(`\xNN`、`\u{NNNNNN}`)が使える。

## 文字列リテラル

- `"`(ダブルクォーテーション)で囲われた文字列。
- UTF-8エンコードされたバイト列として扱われる。
- 文字列リテラルの型は`*const [N:0]u8`で、NはUTF-8で表わした時のバイト数。
- エスケープシーケンスが使える。

### 複数行文字列リテラル

- `\\`で始まる連続した行は複数行文字列リテラルになる。
- `\\`の後ろから行の最後までと、次の行も`\\`で始まる場合、改行文字(`\n`)を加えて連続した文字列として扱われる。
- エスケープシーケンスが使えない。

## 列挙型リテラル

- `<型>.<識別子>`
- 型を省略すると列挙型リテラルになる。
- 列挙型リテラルの型は`@TypeOf(.enum_literal)`。

## 構造体リテラル

- `<型>{[<フィールド初期化>, ...]}`
- 型を省略して`.`にできる。
- `,`(カンマ)区切りでフィールドの値を初期化できる。
- フィールドは`.<フィールド名> = <値>`のように書く。
- フィールドを`<値>`のように書くとタプルリテラルになる。

## エラーリテラル

- `error.<識別子>`
- エラーリテラルの型は`error{<識別子>}`。

## `undefined`リテラル

- 代入文で値を未定義にする。
