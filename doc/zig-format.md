`fn format(writer: anytype, comptime fmt: []const u8, args: anytype) !void`

バイトのスライスで `writer` を呼び出して、引数付きの fmt 文字列をレンダリングします。`writer` がエラーを返す場合、エラーは `format` から返され、`writer` は再度呼び出されません。

フォーマット文字列は、comptime で認識される必要があり、次の形式に従うプレースホルダーを含めることができます:
`{[argument][specifier]:[fill][alignment][width].[precision]}`

上記の各単語とその周囲の [ および ] は、何かに置き換える必要があるパラメータです:

- *argument*は、挿入する引数の数値インデックスまたはフィールド名です。
  - フィールド名を使用する場合は、フィールド名 (識別子) を角括弧で囲む必要があります (例: {[score]...})。これは、数値インデックス形式 (例: {2...}) とは対照的です。
- *specifier*は、型をどのようにフォーマットするかを決定する型依存のフォーマットオプションです (以下を参照)
- *fill*は、フォーマットされたテキストを埋め込むために使用される単一のUnicodeコードポイントです。
- *alignment*は、テキストをそれぞれ左揃え、中央揃え、右揃えにするための 3 つのバイト '<'、'^'、'>' のいずれかです。
- *width*はUnicodeコードポイントでのフィールドの合計幅です
- *precision*は、フォーマットされた数値の小数点以下の桁数を指定します。

ほとんどのパラメータはオプションであり、省略できることに注意してください。また、区切り文字の後のすべてのパラメータを省略する場合は、`:` や `.` などの区切り文字を省略することもできます。
唯一の例外は*fill*パラメータです。*fill*が必要な場合は、*alignment*も指定する必要があります。そうしないと、`:`の後の数字は*fill*ではなく*width*として解釈されます。

*specifier*には、型に関するいくつかのオプションがあります:

- `x` and `X`: 16進数表記で数値を出力します
- `s`:
  - u8の多対多ポインタとCポインタの場合、ゼロ終端を使用してC文字列として印刷します。
  - u8のスライスの場合、スライス全体をゼロ終端なしの文字列として出力します。
- `e`: 浮動小数点値を科学的記数法で出力する
- `d`: 数値を10進数で出力する
- `b`: 整数値を2進数で出力する
- `o`: 8進表記の整数値を出力する
- `c`: 整数を ASCII 文字として出力します。整数型は最大 8 ビットである必要があります。
- `u`: 整数を UTF-8 シーケンスとして出力します。整数型は最大 21 ビットである必要があります。
- `?`: オプションの値をラップされていない値または `null` として出力します。その後に、基になる値の書式指定子が続く場合があります。
- `!`: エラー ユニオン値をラップされていない値またはフォーマットされたエラー値として出力します。その後に、基になる値の書式指定子が続く場合があります。
- `*`: 値自体ではなく、値のアドレスを出力します。
- `any`: デフォルトの形式を使用して任意の型の値を出力します。

フォーマットされたユーザー型に次の型の関数が含まれている場合

```
pub fn format(value: ?, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void
```

`?` がフォーマットされた型である場合、この関数はデフォルトの実装の代わりに呼び出されます。これにより、型のすべてのフィールドをダンプするのではなく、ユーザー型を論理的な方法でフォーマットできます。

ユーザー型は、`struct`、`vector`、`union`、または `enum` 型になります。

リテラルの中括弧を印刷するには、`{{` または `}}` のように 2 回記述してエスケープします。
