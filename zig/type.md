# 型

- Zigの型を確認する。
- データを表すもの
- やる: 型の操作について
- やる: 型変換について

## 整数型

- 整数。
- 符号付き(`i<ビットサイズ>`)、符号なし(`u<ビットサイズ>`)がある。
- ポインタサイズの`usize`と`isize`がある。
- ビットサイズは0から65535ビットまである。
- 符号付き整数は2の補数で表現される。

## 浮動小数点数型

- 浮動小数点数。
- `f16`
- `f32`
- `f64`
- `f80`
- `f128`
- 半精度、単精度、倍精度、拡張倍精度、四倍精度がある。
- IEEE-754-2008に準拠している。

## コンパイル時整数

- コンパイル時に決定される整数。
- `comptime_int`
- 整数リテラルとUnicodeコードポイントリテラルの型。

## コンパイル時浮動小数点数

- コンパイル時に決定される浮動小数点数。
- `comptime_float`
- 浮動小数点数リテラルの型。

## 論理値型

- `bool`
- 真偽値を表す。
- `true`、`false`の2種類がある。

## C-ABI互換型

- C言語のABIと互換性を持つための型。
- `c_char` C言語の`char`型。
- `c_short` C言語の`short`型。
- `c_int` C言語の`int`型。
- `c_long` C言語の`long`型。
- `c_longlong` C言語の`long long`型。
- `c_ushort` C言語の`unsigned short`型。
- `c_uint` C言語の`unsigned int`型。
- `c_ulong` C言語の`unsigned long`型。
- `c_ulonglong` C言語の`unsigned long long`型。
- `c_longdouble` C言語の`long double`型。

## 配列型

- `[<サイズ>]<アイテムの型>`
- `[_]<アイテムの型>`
- `[<サイズ>:<番兵の値>]<アイテムの型>`
- 同じ型が連続して配置される型。
- 配列のサイズはコンパイル時に決定される。
- 配列の初期化に使用する場合、サイズを省略できる。
- 番兵を指定すると、番兵付き配列になる。

## ベクトル型

- `@Vector(<サイズ>, <アイテムの型>)`
- 同じ型が連続して配置される型。
- ベクトルのサイズはコンパイル時に決定される。
- アイテムの型は整数型、浮動小数点数型、論理値型、ポインター型が使用できる。
- ベクトルはアイテムの型と同じ演算子を使用できる。

## ポインター型

### 単要素ポインター型

- `*<アイテムの型>`
- `*allowzero align(<アラインメント>) const volatile <アイテムの型>`
- アイテムの型を指すポインター。
- `const`ポインターはポインターの値を変更することができない。
- 書き込み、読み込みに副作用がある場合に`volatile`を指定する。
- `align`でポインターの指す値のアラインメントを指定できる。
- アラインメントの値は2のべき乗の値を指定できる。
- 0アドレスを指す場合に`allowzero`を指定する。

### 複数要素ポインター型

- `[*]<アイテムの型>`
- `[*:<番兵の値>]<アイテムの型>`
- 複数の要素を持つポインター。

### Cポインター型

- `[*c]<アイテムの型>`
- C言語のポインター。
- 単要素ポインターと複数要素ポインターの操作ができる。

## スライス型

- `[]<アイテムの型>`
- `[:<番兵の値>]<アイテムの型>`
- fatポインター。
- 複数要素ポインターと長さを持つ。

## 構造体型

- `struct {<フィールド名>:<型>, ...}`
- `struct {<フィールド名>:<型>=<初期値>, ...}`
- 複数の値をまとめた型。
- 0個以上のフィールド名と型のペアを持つ。
- フィールドはデフォルトの値を持つことができる。
- `extern struct`はC-ABIとの互換性がある。
- `packed struct`はメモリ内レイアウトが保証される。

## タプル型

- `struct {<型>, ...}`
- `struct {<型>=<初期値>, ...}`
- 複数の値をまとめた型。
- 構造体と違い、フィールド名を持たない。
- フィールドはデフォルトの値を持つことができる。
- `extern struct`と`packed struct`はタプルに使用できない。

## 列挙型

- `enum {<識別子>, ...}`
- `enum(<タグ>) {<識別子>, ...}`
- `enum(<タグ>) {<識別子>=<順序値>, ...}`
- `enum(<タグ>) {<識別子>, ..., _}`
- 識別子の集合を表す型。
- 整数型のタグを指定できる。
- タグがある場合、順序値を指定できる。
- `_`を指定すると非網羅的な列挙型になる。

## 共用体型

- `union {<識別子>:<型>, ...}`
- `union(<タグ>) {<識別子>:<型>, ...}`
- `union(enum) {<識別子>:<型>, ...}`
- 複数の型のどれか一つを表す型。
- 列挙型のタグを付けることができる。
- タグの替わりに`enum`を使うと推論されたタグ型になる。
- `extern union`はC-ABIとの互換性がある。
- `packed union`はメモリ内レイアウトが保証される。

## 不透明型

- `opaque {}`
- サイズとアラインメントが不明な型。

### anyopaque型

- `anyopaque`
- 任意の不透明型。
- 型の消去されたポインターに使用される。

## エラー集合型

- `error {<識別子>, ...}`
- 識別子で表したエラーの集合型。

### anyerror型

- `anyerror`
- コンパイルに含まれるすべてのエラーの集合型。

## エラー共用体型

- `<エラー>!<型>`
- `!<型>`
- エラー値または正常値を表す型。
- エラーはエラー集合型を使う。
- 関数の戻り値の型に`!<型>`を使うと、推論されたエラー集合型になる。

## オプション型

- `?<型>`
- 無効な値の可能性がある型。
- 無効な値の場合、`null`を使う。

## 関数型

- `fn (<引数>, ...) <戻り値>`
- 関数を表す型。
- 関数型は*comptime-known*。
- 関数型の`const`ポインター型は*runtime-known*の型になる。

## タイプ型

- `type`
- 型を表す型。
- タイプ型は*comptime-known*。
- `type`もタイプ型。

## その他の型

### void型

- `void`
- 値がないことを表す。

### noreturn型

- `noreturn`
- 戻り値を得ることがないことを表す。
- `noreturn`として扱われる型がある。
  ([#13807](https://github.com/ziglang/zig/issues/13807),
  [#15909](https://github.com/ziglang/zig/issues/15909))

### anytype型

- `anytype`
- 任意の型。
- コンパイル時に型が決定する。
- 関数の引数の型に使用できる。

## 型のアラインメント

- `<型> align(<アラインメント>)`
